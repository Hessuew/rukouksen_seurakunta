---
import FilterButtons from './FilterButtons.astro';
import SearchInput from './SearchInput.astro';
import WidgetWrapper from '~/components/ui/WidgetWrapper.astro';

interface Props {
  options: string[] | string[][];
  allLabels?: string[];
  showSearch?: boolean;
  id?: string;
  classes?: Record<string, string>;
  isDark?: boolean;
  bg?: string;
  gridId?: string;
}

const {
  options,
  allLabels = ['All'],
  showSearch = true,
  id,
  classes = {},
  isDark = false,
  bg = await Astro.slots.render('bg'),
  gridId,
} = Astro.props;

const buttonGroups = Array.isArray(options[0]) ? options : [options];
const labels = Array.isArray(allLabels) ? allLabels : [allLabels];
---

<WidgetWrapper id={id} isDark={isDark} containerClass={classes?.container ?? `max-w-7xl mx-auto`} bg={bg}>
  <div class="w-full">
    <div class="flex flex-col gap-4">
      <div class="flex flex-wrap-reverse items-center gap-4">
        <div class="flex-1 min-w-0">
          <FilterButtons options={buttonGroups[0] as string[]} allLabel={labels[0]} variant="type" />
        </div>
        {
          showSearch && (
            <div class="w-full md:w-auto md:min-w-[300px]">
              <SearchInput gridId={gridId} />
            </div>
          )
        }
      </div>
      {
        buttonGroups[1] && (
          <div class="w-full">
            <FilterButtons options={buttonGroups[1] as string[]} allLabel={labels[1]} variant="category" />
          </div>
        )
      }
    </div>
  </div>
</WidgetWrapper>

<script>
  // Keep track of current filter states
  const currentFilters = {
    type: 'all',
    category: 'all',
    search: '',
  };

  function applyFilters() {
    const pressReleaseCards = document.querySelectorAll('.item-card');
    const searchTerm = currentFilters.search.toLowerCase();

    pressReleaseCards.forEach((card) => {
      const cardType = card.getAttribute('data-type');
      const cardCategory = card.getAttribute('data-category');

      // Check type and category filters
      const typeMatch = currentFilters.type === 'all' || cardType === currentFilters.type;
      const categoryMatch = currentFilters.category === 'all' || cardCategory === currentFilters.category;

      // Check search term against card content
      const cardContent = card.textContent?.toLowerCase() || '';
      const searchMatch = !searchTerm || cardContent.includes(searchTerm);

      card.classList.toggle('hidden', !searchMatch || !typeMatch || !categoryMatch);
    });

    // Hide empty year sections
    document.querySelectorAll('.item-year-card').forEach((yearSection) => {
      const hasVisibleCards = yearSection.querySelectorAll('.item-card:not(.hidden)').length > 0;
      yearSection.classList.toggle('hidden', !hasVisibleCards);
    });
  }

  function handleFilterChange(event) {
    const target = event.target;
    if (!target.hasAttribute('data-filter')) return;

    const filterType = target.getAttribute('data-filter-type');
    const filterValue = target.getAttribute('data-filter');
    if (filterType === 'type') {
      currentFilters.type = filterValue;
    } else if (filterType === 'category') {
      currentFilters.category = filterValue;
    }

    applyFilters();
  }

  function handleSearch(event) {
    const target = event.target;
    if (!target.hasAttribute('data-search-input')) return;

    currentFilters.search = target.value;
    applyFilters();
  }

  // Initialize intersection observer for animations
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          entry.target.classList.add('intersected');
          observer.unobserve(entry.target);
        }
      });
    },
    {
      root: null,
      threshold: 0.1,
      rootMargin: '0px',
    }
  );

  // Observe all elements with animation classes
  document.addEventListener('DOMContentLoaded', () => {
    const elements = document.querySelectorAll('.intersect-once');
    elements.forEach((el) => observer.observe(el));
  });

  // Setup filter event listeners
  document.addEventListener('click', handleFilterChange);

  // Setup search input listener
  const searchInput = document.querySelector('[data-search-input]');
  if (searchInput) {
    searchInput.addEventListener('input', handleSearch);
  }

  // Initialize filters
  applyFilters();
</script>
